From 6f2e2862767f07358d85b53d6237e16ead11a47e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Storsj=C3=B6?= <martin@martin.st>
Date: Fri, 8 May 2020 13:46:11 +0300
Subject: [PATCH 4/8] WIP: Use hardware encoders via MediaFoundation

Hook up a swscale converter right before, just like in enc_qsv.c.
---
 libhb/encavcodec.c | 44 +++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 43 insertions(+), 1 deletion(-)

diff --git a/libhb/encavcodec.c b/libhb/encavcodec.c
index a3f26e833..cf4d26816 100644
--- a/libhb/encavcodec.c
+++ b/libhb/encavcodec.c
@@ -45,6 +45,9 @@ struct hb_work_private_s
     } frame_info[FRAME_INFO_SIZE];
 
     hb_chapter_queue_t * chapter_queue;
+
+    struct SwsContext  * sws_context_to_nv12;
+    hb_buffer_t        * nv12_buf;
 };
 
 int  encavcodecInit( hb_work_object_t *, hb_job_t * );
@@ -611,7 +614,20 @@ int encavcodecInit( hb_work_object_t * w, hb_job_t * job )
     if (job->vcodec == HB_VCODEC_FFMPEG_MF_H264 ||
         job->vcodec == HB_VCODEC_FFMPEG_MF_H265)
     {
-//        av_dict_set(&av_opts, "hw_encoding", "1", 0);
+        av_dict_set(&av_opts, "hw_encoding", "1", 0);
+
+        pv->sws_context_to_nv12 = hb_sws_get_context(
+                                    job->width, job->height,
+                                    AV_PIX_FMT_YUV420P,
+                                    job->width, job->height,
+                                    AV_PIX_FMT_NV12,
+                                    SWS_LANCZOS|SWS_ACCURATE_RND,
+                                    SWS_CS_DEFAULT);
+
+        pv->nv12_buf = hb_frame_buffer_init(
+                         AV_PIX_FMT_NV12, job->width, job->height);
+
+        context->pix_fmt = AV_PIX_FMT_NV12;
     }
 
     if( job->pass_id == HB_PASS_ENCODE_1ST ||
@@ -761,6 +777,14 @@ void encavcodecClose( hb_work_object_t * w )
         }
         hb_avcodec_free_context(&pv->context);
     }
+    if (pv->sws_context_to_nv12 != NULL)
+    {
+        sws_freeContext(pv->sws_context_to_nv12);
+    }
+    if (pv->nv12_buf != NULL)
+    {
+        hb_buffer_close(&pv->nv12_buf);
+    }
     if( pv->file )
     {
         fclose( pv->file );
@@ -921,6 +945,24 @@ static void Encode( hb_work_object_t *w, hb_buffer_t *in,
     frame.linesize[1] = in->plane[1].stride;
     frame.linesize[2] = in->plane[2].stride;
 
+    if (pv->sws_context_to_nv12)
+    {
+        uint8_t *srcs[]   = { in->plane[0].data, in->plane[1].data, in->plane[2].data };
+        int srcs_stride[] = { in->plane[0].stride, in->plane[1].stride, in->plane[2].stride };
+        uint8_t *dsts[]   = { pv->nv12_buf->plane[0].data, pv->nv12_buf->plane[1].data, NULL };
+        int dsts_stride[] = { pv->nv12_buf->plane[0].stride, pv->nv12_buf->plane[1].stride, 0 };
+
+        sws_scale(pv->sws_context_to_nv12,
+                  (const uint8_t* const*)srcs, srcs_stride,
+                  0, in->f.height, dsts, dsts_stride);
+
+        for (int i = 0; i < 3; i++)
+        {
+            frame.data[i] = dsts[i];
+            frame.linesize[i] = dsts_stride[i];
+        }
+    }
+
     if (in->s.new_chap > 0 && pv->job->chapter_markers)
     {
         /* chapters have to start with an IDR frame so request that this
-- 
2.17.1

